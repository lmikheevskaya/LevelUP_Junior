#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <condition_variable>

void some_function(); 
void some_other_function();

int main()
{
	//создается новый поток и связывается с объектом t1
	std::thread t1(some_function); 
	//владение явно передается объекту t2 в момент его конструирования путем вызова std::move()
	std::thread t2=std::move(t1); 
	//В этот момент с t1 уже не связан никакой поток выполнения: поток, в котором исполняется функция some_function, теперь связан с t2.
	
	//создается еще один поток, который связывается с временным объектом типа std::thread

	//Для последующей передачи владения объекту tl уже не требуется явный вызов std::move (), 
	//так как владельцем является временный объект, а передача владения от временных объектов производится автоматически и неявно.
	t1=std::thread(some_other_function); 

	//Объект t3 конструируется по умолчанию - в момент создания с ним не связывается никакой поток
	std::thread t3; 

	//Владение потоком, который в данный момент связан с t2, передается объекту t3 путем явного обращения к std::move (), т.к t2 - именованный объект
	t3=std::move(t2); 

	//tl оказывается связан с потоком, исполняющим функцию some other function, t2 не связан ни с каким потоком, 
	//a t3 связан с потоком, исполняющим функцию some function.


	//передает владение потоком, исполняющим some function, обратно объекту tl, в котором исполнение этой функции началось. 
	//Однако теперь с tl уже связан поток (который исполнял функцию some_other_function), поэтому вызывается std::terminate (), 
	//и программа завершается. Так делается ради совместимости с поведением деструктора std::thread.
	t1=std::move(t3);


	//нужно либо явно ждать завершения потока, либо отсоединить его до момента уничтожения; то же самое относится и к присваиванию: 
	//нельзя просто «прихлопнуть» поток, присвоив новое значение объекту std::thread, который им управляет.
 
    return 0;
}
