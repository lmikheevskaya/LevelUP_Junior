#include <mutex>
#include <algorithm>

class some_big_object
{
};
void swap(some_big_object& lhs,some_big_object& rhs);

class X 
{
	private:
	some_big_object some_detail; 
	std::mutex m; 

public:
	X(some_big_object const& sd):some_detail(sd){} friend void swap(X& lhs, X& rhs)
	{
		//проверяется, что в аргументах переданы разные экземпляры, поскольку попытка 
		//захватить std::mutex, когда он уже захвачен, приводит к неопределенному поведению.
		if(&lhs == &rhs) 
			return;
		//вызываем std::lock(), чтобы захватить оба мьютекса
		std::lock(lhs.m, rhs.m);

		//конструируем два экземпляра std::lock guard,  - по одному для каждого мьютекса. Помимо самого мьютекса, 
		//конструктору передается параметр std::adopt lock, сообщающий объектам std::lock guard, что мьютексы уже 
		//захвачены, и им нужно лишь принять владение существующей блокировкой, а не пытаться еще раз захватить 
		//мьютекс в конструкторе.
		std::lock_guard<std::mutex> lock_a(lhs.m, std::adopt_lock);
		std::lock_guard<std::mutex> lock_b(rhs.m, std::adopt_lock); 
		swap(lhs.some_detail, rhs.some_detail);


		//Это гарантирует корректное освобождение мьютексов при выходе из функции даже в случае, когда защищаемая 
		//операция возбуждает исключение, а также возврат результата сравнения в случае нормального завершения.

		//Хотя std::lock помогает избежать взаимоблокировки в случаях, когда нужно захватить сразу два или 
		//более мьютексов, она не в силах помочь, если мьютексы захватываются порознь, - в таком случае остается 
		//полагаться только на дисциплину программирования.
	}
};

int main()
{
	return 0;
}
