#include "stdafx.h"
#include <iostream>
#include <thread>
#include <string>

int main()
{
	auto func = [](const std::string& first, const std::string& second)
	{
		std::cout << first << second;
	};

	//первым параметром передается функция исполнения т.е. функция код которой будет исполнятся в отдельном потоке
	//Остальные аргументы, - аргументы исполняемой функции
	//Функция начинает свое исполнения сразу по окончании работы конструктора std::thread
	//Завершение потока происходит по завершении работы исполняемой функции
	std::thread my_thread(func, "Hello, ", "threads!");
	//thread.join() - поток исполнения, будет ожидать завершения исполнения созданного потока. Блокирует вызывающий поток
	my_thread.join();
	//thread.detach() - пользователя не интересует судьба созданного потока и главный поток исполнения может завершится до того как будет завершён оный. Не блокирует вызывающий поток.
	//my_thread.detach();
	//Ни один из вышеупомянутых методов не был вызван.Это приведёт к вызову std::termination в деструкторе объекта thread.
}

//get_id – возвращает идентификатор потока исполнения, в котором она вызвана
//yield – сигнализирует ОС, что поток желает приостановить свое выполнение и дать шанс на исполнение другим потокам.Результат зависит от многих факторов и ОС, поэтому не думаю, что его стоит обсуждать.
//sleep_until – поток приостанавливает выполнение до наступления момента, переданного в качестве аргумента.
//sleep_for – поток приостанавливает выполнение на некий, заданный промежуток времени.
/*
auto days = std::chrono::system_clock::now() + std::chrono::hours(72);
std::this_thread::sleep_until(days);
std::this_thread::sleep_for(std::chrono::hours(72));
Обе функции кладут поток в сон на 3 дня.
*/
