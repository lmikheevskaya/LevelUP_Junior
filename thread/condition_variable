http://xydan.livejournal.com/8595.html
//std::condition_variable
/*
нужно, чтобы поток ожидал наступления некого события. Один из вариантов реализации - регулярно в цикле проверять 
условие наступления события, но это не эффективно, так как поток, вместо того, чтобы спать до наступления нужного 
момента, постоянно спрашивает о статусе, тем самым, мешая другим потокам.

std::condition_variable - это объект синхронизации, предназначенный для блокирования одного потока, пока он не 
будет оповещен о наступлении некоего события из другого.

Основными методами condition_variable являются:

wait – ставит поток в ожидание сигнала. Ожидание не лимитировано временем. Может принимать в качестве аргумента предикат,
от результата которого будет зависеть выход потока из ожидания. Т.е. если даже wait был завершен благодаря сигналу, происходит 
проверка предиката после чего поток снова становится в ожидание, если предикат ложен. На псевдокоде: (while(!predicate) wait;).
А нужно это, в первую очередь, для того, чтобы избежать реагирования на фальшивое(spurious) пробуждение(см. врезку ниже).

wait_for – Ожидание лимитировано согласно аргументу
wait_until - Ожидание лимитировано согласно аргументу
notify_one – Посылает сигнал одному из ожидающих потоков; т.е. разблокирует один поток. Какой поток будет разбужен – не известно. 
Гарантировано лишь то, что один из них будет.
notify_all – Посылает сигнал всем ожидающим потокам; т.е. разблокирует все потоки ожидающие на данном объекте condition_variable

condition_variable не является самостоятельным примитивом, т.к. wait происходит на объекте std::unique_lock. При этом unique_lock 
должен быть захвачен перед тем как будет передан в функцию wait. Более того, вы должны гарантировать, что все wait, для данного 
объекта condition_variable, выполнены на одном и том же мьютексе. 

Есть и другой тип condition_variable, – condition_variable_any, который, в отличие от своего собрата, может принимать любой объект, 
на котором можно выполнить lock/unlock. А это все мьютексы и обертки для них(lock_guard, unique_lock). Пользователь, так же, может 
добавить свой тип. 

*/
//Один, заурядный, менеджера приходит на работу звонит в звонок и ждёт пока охранник откроет ему дверь:


/*
#include <iostream>
#include <vector>
#include <thread>

std::vector<int> data;
std::condition_variable data_cond;
std::mutex m;

void thread_func1()
{
	std::unique_lock<std::mutex> lock(m);
	data.push_back(10);
	data_cond.notify_one();
}

void thread_func2()
{
	std::unique_lock<std::mutex> lock(m);
	data_cond.wait(lock, [] {
		return !data.empty();
	});
	std::cout << data.back() << std::endl;
}

int main()
{
	std::thread th1(thread_func1);
	std::thread th2(thread_func2);
	th1.join();
	th2.join();
}*/
