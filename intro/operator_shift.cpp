int main()
{
	//0
	//Битовые операторы
	unsigned char a, b, c, d, e, f;
    	a = 5; // 00000101
    	b = 6; // 00000110
     
    	c = a & b; // 00000100 == 4
    	d = a | b; // 00000111 == 7
    	e = a ^ b; // 00000011 == 3
    	f =  ~ a ; // 11111010 == 250
	
	//1
	/*int a = 5;      // в двоичной системе: 0000000000000101
	int b = a << 3;   // в двоичной системе: 0000000000101000, или 40 в десятичной
	int c = b >> 3;   // в двоичной системе: 0000000000000101, или снова 5, как было изначально
	*/
	//2
	//Следует иметь ввиду, что при сдвиге значения x на y бит (x<<y), самые левые y бит в исходном 
	//числе x теряются, т.к. они буквально выталкиваются за его пределы.
	//int a = 5;       // в двоичной системе: 0000000000000101
	//int b = a << 14;   // в двоичной системе: 0100000000000000 - первая 1 в 101 исчезла
	

	//3
	//Если вы уверены, что ни один из битов в сдвигаемом числе не пропадет, то для простоты можно 
	//считать, что оператор сдвига << умножает левый операнд на 2 в степени, показателем которой 
	//является правый операнд. Например, для получения степеней 2 могут быть использованы следующие выражения:

	/*int a = 1 <<  0; // ==    1
	a = 1 <<  1;  //==    2
	a = 1 <<  2;  //==    4
	a = 1 <<  3;  //==    8

	a = 1 <<  8;  //==  256
	a = 1 <<  9;  //==  512
	a = 1 << 10;  //== 1024
	*/

	//4
	//Если вы сдвигаете x вправо на y бит (x>>y) и при этом старшим битом x является 1,  то результат такой операции 
	//будеть зависеть от типа переменной x. в переменных типа int старший бит является знаковым битом, определяющим 
	//является ли число положительным или отрицательным. Если переменная x имеет тип int, то при сдвиге x вправо 
	//знаковый бит копируется в младшие биты (по историческим причинам):
	/*
	int x = -16;     // в двоичной системе: 1111111111110000
	int y = x >> 3;  // в двоичной системе: 1111111111111110
	*/

	//5
	//Такое поведение называется расширением знака и, как правило, нежелательно: вместо единиц пользователь чаще ожидает 
	//увидеть нули в левой части x на месте свдинутых бит. В то же время для беззнаковых целых чисел (переменные типа unsigned int) 
	//действуют другие правила сдвига вправо. Поэтому для предотвращения копирования единиц в старших разрядах сдвигаемой переменной x, 
	//можно прибегнуть к преобразованию типов:
	/*
	int x = -16;                   // в двоичной системе: 1111111111110000
	int y = (unsigned int)x >> 3;  // в двоичной системе: 0001111111111110
	*/

	//int x = 1000;
	//int y = x >> 3; // целочисленное деление 1000 на 8, в результате которого y = 125

}
